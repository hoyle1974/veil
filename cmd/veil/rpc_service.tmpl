package {{.PackageName}}


import (
    "context"
    "github.com/hoyle1974/veil/veil"
    "github.com/keegancsmith/rpc"
{{range .Packages}}     "{{.}}"
{{end}}
)

{{range .Structs}}
{{ $struct := . }}
// This is an interface that defines the publically exposed methods for the struct '{{.Name}}'
type {{.InterfaceName}} interface {
{{range .Methods}}
    {{.Name}}(ctx context.Context{{range .Args}}, {{.Name}} {{.Type}}{{end}}) ({{range $index, $element := .Returns}}{{if $index}},{{end}}{{$element}}{{end}}){{end}}
}

type {{.RPCName}} struct {
    service *{{.Name}}
}

func (r *{{$struct.RPCName}}) RPC_Bind_Service(service any) error {
    s, ok := service.(*{{.Name}})
    if !ok {
        return errors.New("not supported service")
    }
    r.service = s
    return nil
}

{{ $struct = . }}
{{range .Methods}}
func (r *{{$struct.RPCName}}) {{.Name}}(ctx context.Context, request *{{$struct.RemoteImplName}}_{{.Name}}_Request, reply *[]any) error {
	if (r.service == nil) {
        return errors.New("service {{.Name}} not initialized")
    }
    {{range $idx, $element := .Returns}} {{if $idx}},{{end}} ret{{$idx}} {{end}} := r.service.{{.Name}}(
		ctx,{{range .Args}}
        request.{{title .Name}},{{end}}
	){{range $idx, $element :=  .Returns }}
    *reply = append(*reply, ret{{$idx}}){{end}}
    
	return nil
}
{{end}}

// This is a remote implementation client that will send RPC commands to a remote '{{.Name}}'
type {{.RemoteImplName}} struct {
    conn *rpc.Client
}
{{ $save := . }}
{{range .Methods}}
// Request Object
type {{$save.RemoteImplName}}_{{.Name}}_Request struct { {{range .Args}}
    {{title .Name}} {{.Type}}{{end}}
}
// Method
func (r *{{$save.RemoteImplName}}) {{.Name}}(ctx context.Context{{range .Args}},{{.Name}} {{.Type}}{{end}}) ({{range $index, $element := .Returns}}{{if $index}},{{end}}{{$element}}{{end}}) {
    request := {{$save.RemoteImplName}}_{{.Name}}_Request{ {{range $index, $element := .Args}}{{if $index}},{{end}}{{$element.Name}}{{end}} }

    reply := []any{}
{{range $index, $element := .Returns}}      var result{{$index}} {{$element}}
{{end}}
    err := r.conn.Call(ctx, "{{$save.RPCName}}.{{.Name}}", request, &reply)
    if err != nil {
        result{{ lastItemIndex .Returns }} = err
	} else { {{range $index, $element := .Returns}} 
        result{{$index}} = internal_{{$save.RemoteImplName}}_nilGet[{{$element}}](reply[{{$index}}]){{end}}
	}
    return {{range $index, $element := .Returns}}{{if $index}},{{end}}result{{$index}} {{end}}
}
{{end}}

func internal_{{$save.RemoteImplName}}_nilGet[T any](a any) T {
	var zero T
	if a == nil {
		return zero
	}
	return a.(T)
}

{{end}}



func init() {

	veil.RegisterServerInit(func() {
{{range .Structs}}
            r := &{{.RPCName}}{}
            if err := rpc.Register(r); err!=nil {
                panic(err)
            }
            veil.RegisterService(r)
{{end}}
    }) // RegisterServerInit

    
	veil.RegisterClientInit(func(factory veil.ConnectionFactory) {
{{range .Structs}}
        veil.RegisterRemoteImpl(&{{ .RemoteImplName}}{factory.GetConnection().(*rpc.Client)})
{{end}}
    }) // RegisterClientInit
}

